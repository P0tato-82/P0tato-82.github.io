<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mysql语句</title>
    <link href="/2021/03/04/Mysql%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95-0/"/>
    <url>/2021/03/04/Mysql%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95-0/</url>
    
    <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>SQL操作数据库时所有语句以分号结束。</p><p>SQL语句不区分大小写。</p><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><ol><li><p>连接MySQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sudo mysql<br></code></pre></td></tr></table></figure></li><li><p>查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database MyFirstDB;<br></code></pre></td></tr></table></figure></li><li><p>创建库时设置字符编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database MyFirstDB <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br><br>或者<br><br><span class="hljs-keyword">create</span> database MyFirstDB charset utf8;<br></code></pre></td></tr></table></figure><p>不设置编码则默认编码为<strong>latin1(单字节编码)</strong></p></li><li><p>查看数据库的编码方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> database MyFirstDB;<br></code></pre></td></tr></table></figure></li><li><p>修改数据库编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> database MyFirstDB <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br></code></pre></td></tr></table></figure></li><li><p>使用<code> ues 数据库名 </code>进入数据库</p><blockquote><p>可以不要分号</p></blockquote></li><li><p>显示当前数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> database();<br></code></pre></td></tr></table></figure><h1 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h1></li><li><p>查看当前数据库的全部表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> tables;<br></code></pre></td></tr></table></figure></li><li><p>创建表 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(字段<span class="hljs-number">1</span> 字段类型,字段<span class="hljs-number">2</span> 字段类型,字段<span class="hljs-number">3</span> 字段类型,......);<br></code></pre></td></tr></table></figure></li><li><p>向表中添加字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 字段名 数据类型<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> flag <span class="hljs-keyword">add</span> createtime <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>显示表信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 所创建的表;<br><span class="hljs-keyword">desc</span> 表名;<br></code></pre></td></tr></table></figure></li><li><p>删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> flag <span class="hljs-keyword">drop</span> createtime;<br></code></pre></td></tr></table></figure></li><li><p>修改数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> flag modify createtime <span class="hljs-type">INT</span>(<span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure></li><li><p>字段改名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 change 原字段名 新字段名 数据类型;<br><br>eg:<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> Phone_table change name pname <span class="hljs-type">CHAR</span>(<span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(列<span class="hljs-number">1</span>，列<span class="hljs-number">2</span>，列<span class="hljs-number">3</span>)<br><span class="hljs-keyword">VALUES</span><br>(值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CTF】模板注入学习</title>
    <link href="/2021/01/28/%5BCTF%5D%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/01/28/%5BCTF%5D%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前置简介"><a href="#前置简介" class="headerlink" title="前置简介"></a>前置简介</h1><h2 id="SSTI的简单讲解"><a href="#SSTI的简单讲解" class="headerlink" title="SSTI的简单讲解"></a>SSTI的简单讲解</h2><p>SSTI 全称Server Side Template Injection，服务器模板注入。模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。</p><p>与此同时，它也扩展了黑客的攻击面。除了常规的 XSS 外，注入到模板中的代码还有可能引发 RCE（远程代码执行）。通常来说，这类问题会在博客，CMS，wiki 中产生。虽然模板引擎会提供沙箱机制，攻击者依然有许多手段绕过它。</p><p>服务器模板注入（Server-side template injection）是当攻击者能够用本地的模板语法去注入一个恶意的payload，然后再服务器端执行该模板的攻击手法。</p><h2 id="为什么需要服务器模板"><a href="#为什么需要服务器模板" class="headerlink" title="为什么需要服务器模板"></a>为什么需要服务器模板</h2><p>简单来说，页面上的数据需要不断更新，即为渲染。后台语言通过一些模板引擎生成HTML。</p><p>因为Web Application 最终是要落实到HTML、CSS、JavaScript等用户界面上的，有时每一个页面都需要特殊的逻辑，随着应用功能的增加，而且彼此之间没有同步，想要修改某一属性可能就要修改成百上千个HTML文件。</p><p>既然如此多的HTML具有一定的逻辑联系，何不使用代码生成代码？于是后端模板语言诞生了。分别有前端渲染和后端（服务器）渲染，区别是：</p><p>后端渲染是将一些模板规范语言翻译成如上三种语言回传给前端；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h2><h3 id="文本类"><a href="#文本类" class="headerlink" title="文本类"></a>文本类</h3><p>大部分的模板语言支持我们输入 HTML，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">smarty=Hello &#123;user.name&#125;<br>Hello user1<br> <br>freemarker=Hello $&#123;username&#125;<br>Hello newuser<br> <br>any=<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Hello<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><br></code></pre></td></tr></table></figure><p>未经过滤的输入会产生 XSS，我们可以利用 XSS 做我们最基本的探针。除此之外，模板语言的语法和 HTML 语法相差甚大，因此我们可以用其独特的语法来探测漏洞。虽然各种模板的实现细节不大一样，不过它们的基本语法大致相同，我们可以发送如下payload确认漏洞</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">smarty</span>=Hello <span class="hljs-variable">$&#123;7*7&#125;</span><br>Hello 49<br> <br><span class="hljs-attribute">freemarker</span>=Hello <span class="hljs-variable">$&#123;7*7&#125;</span><br>Hello 49<br></code></pre></td></tr></table></figure><h3 id="代码类"><a href="#代码类" class="headerlink" title="代码类"></a>代码类</h3><p>在一些环境下，用户的输入也会被当作模板的可执行代码。比如说变量名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">personal_greeting=username<br>Hello user01<br></code></pre></td></tr></table></figure><p>这种情况下，XSS 的方法就无效了。但是我们可以通过破坏 template 语句，并附加注入的HTML标签以确认漏洞：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">personal_greeting=username<span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span><br>Hello<br>personal_greeting=username&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span><br>Hello user01 <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>一旦发现SSTI漏洞，下一步就是要确定模板引擎。</p><p>尽管有大量的模板语言，但是其中许多模板使用非常相似的语法，而这些语法是专门为不与HTML字符冲突而选择的。因此创建探测有效载荷以测试正在使用哪个模板引擎可能相对简单。</p><p>通常只需提交非法可报错的语法就足够了，因为产生的错误消息将准确告诉你模板引擎是什么，甚至是哪个版本。例如，非法表达式 <strong>&lt;％= foobar％&gt;</strong> 会触发来自基于Ruby的ERB引擎的以下响应：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Ruby">(erb)<span class="hljs-symbol">:</span><span class="hljs-number">1</span><span class="hljs-symbol">:in</span> <span class="hljs-string">`&lt;main&gt;&#x27;: undefined local variable or method `</span>foobar<span class="hljs-string">&#x27; for main:Object (NameError)</span><br><span class="hljs-string">from /usr/lib/ruby/2.5.0/erb.rb:876:in `eval&#x27;</span><br>from /usr/lib/ruby/<span class="hljs-number">2.5</span>.<span class="hljs-number">0</span>/erb.<span class="hljs-symbol">rb:</span><span class="hljs-number">876</span><span class="hljs-symbol">:in</span> <span class="hljs-string">`result&#x27;</span><br><span class="hljs-string">from -e:4:in `</span>&lt;main&gt;<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>有时需要手动测试特定于语言的不同有效负载，并研究模板引擎如何编译它们。常用的方法是使用来自不同模板引擎的语法注入任意数学运算。然后就可以观察它们是否被成功执行。</p><p><img src="https://i.loli.net/2021/01/28/U9E6s15SfKQovAL.png"></p><p>这里的绿线表示结果成功返回，红线反之。有些时候，同一个可执行的 payload 会在不同引擎中返回不同的结果，比方说49会在 Twig 中返回49，而在 Jinja2 中则是7777777。</p><h2 id="python-Web-模板引擎"><a href="#python-Web-模板引擎" class="headerlink" title="python Web 模板引擎"></a>python Web 模板引擎</h2><p>1.Jinja2</p><p>2.Tornado.template</p><p>3.Django.template</p><p>Tornado 中模板渲染函数在有两个：</p><p>1.render</p><p>2.render_string</p><p>Flask 中模板渲染函数也是有两个</p><p>1.render_template</p><p>2.render_template_string</p><p>render_template_string函数在渲染模板的时候使用了%s来动态的替换字符串，在渲染的时候会把双括号包裹的内容当做变量解析替换。</p><p>简而言之就是我们双括号包裹的内容被执行，那么我们可以利用这一点，调用python的类来实现目的。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>攻防世界web进阶Web_python_template_injection<br><img src="https://i.loli.net/2021/01/28/mAy1Ei7dU9qgcOL.png"></p><p>构造paylaod发现模板注入：<br><img src="https://i.loli.net/2021/01/28/dFIDzRB12l4Z7jL.png"></p><p>使用如下命令打印所有文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;[].__class__.__base__.__subclasses__()[<span class="hljs-number">71</span>].__init__.__globals__[<span class="hljs-string">&#x27;os&#x27;</span>].popen(<span class="hljs-string">&quot;ls&quot;</span>).read()&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/28/8kowHefEdbVN2PC.png"></p><p>发现fl4g，将ls改为 cat fl4g即可<br><img src="https://i.loli.net/2021/01/28/6FyNqnc4EmiIgO7.png"></p><hr><h3 id="附部分指令："><a href="#附部分指令：" class="headerlink" title="附部分指令："></a>附部分指令：</h3><p>__class__ 返回类型所属的对象</p><p>__mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</p><p>__base__ 返回该对象所继承的基类</p><blockquote><p>__base__和__mro__都是用来寻找基类的</p></blockquote><p>__subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</p><p>__init__类的初始化方法</p><p>__globals__对包含函数全局变量的字典的引用</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CTF】CTFHUB文件上传</title>
    <link href="/2021/01/28/%5BCTF%5DCTFHUB%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2021/01/28/%5BCTF%5DCTFHUB%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>文件上传漏洞是指攻击者上传了一个可执行的脚本文件到服务器，并执通过此脚本文件获得执行服务端命令的能力。这里上传的文件可以是木马，病毒，恶意脚本，钓鱼图片或者WebShell等。这种攻击方式是最为直接和有效的，</p><h2 id="类型一：无验证"><a href="#类型一：无验证" class="headerlink" title="类型一：无验证"></a>类型一：无验证</h2><p>上传一句话木马，使用蚁剑连接获得flag</p><h2 id="类型二：前端验证"><a href="#类型二：前端验证" class="headerlink" title="类型二：前端验证"></a>类型二：前端验证</h2><p>题目会规定上传类型，如果说判断速度较快基本上可以判断为前端验证。</p><ul><li>方法一：此时写一个一句话木马并保存为可上传的文件。再使用Burp抓包,修改文件后缀为.php即可。</li><li>方法二：浏览器禁用JavaScript，防止验证文件后缀名。</li></ul><h2 id="类型三：-htaccess文件上传"><a href="#类型三：-htaccess文件上传" class="headerlink" title="类型三：.htaccess文件上传"></a>类型三：.htaccess文件上传</h2><blockquote><p>htaccess 文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。- 通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。<br><a href="https://httpd.apache.org/docs/current/howto/htaccess.html">.htassess官方文档</a></p></blockquote><p>法一：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"># FileMatch 参数即为文件名的正则匹配<br><span class="hljs-tag">&lt;<span class="hljs-name">FilesMatch</span> &quot;<span class="hljs-attr">sniperoj</span>&quot;&gt;</span><br>  SetHandler application/x-httpd-php<br><span class="hljs-tag">&lt;/<span class="hljs-name">FilesMatch</span>&gt;</span><br><br>#进行文件名的正则匹配，服务器会对文件名为sniperoj当做php解析<br></code></pre></td></tr></table></figure><p>法二：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">AddType <span class="hljs-built_in">application</span>/x-httpd-php .jpg<br></code></pre></td></tr></table></figure><h1 id="类型四：MIME绕过"><a href="#类型四：MIME绕过" class="headerlink" title="类型四：MIME绕过"></a>类型四：MIME绕过</h1><p>MIME：<br>客户端软件，区分不同种类的数据，例如web浏览器就是通过MIME类型来判断文件是GIF图片，还是可打印的PostScript文件。web服务器使用MIME来说明发送数据的种类， web客户端使用MIME来说明希望接收到的数据种类。<br>服务端MIME类型检测是通过检查http包的Content-Type字段中的值来判断上传文件是否合法的。</p><p>常见的content-type字段：</p><blockquote><p>image/jpeg ：jpg图片格式<br>image/png ：png图片格式<br><br>image/gif ：gif图片格式<br><br>text/plain ：纯文本格式<br><br>text/xml ： XML格式<br><br>text/html ： HTML格式<br><br>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</p></blockquote><hr><p>图片木马的制作：<br>cmd执行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">copy</span> <span class="hljs-selector-tag">logo</span><span class="hljs-selector-class">.jpg</span>/<span class="hljs-selector-tag">b</span>+<span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.php</span>/<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.jpg</span><br></code></pre></td></tr></table></figure><p><strong>logo.jpg</strong> 为任意图片</p><p><strong>test.php</strong> 为我们要插入的木马代码</p><p><strong>test.jpg</strong> 为我们要创建的图片马</p><p><em>格式图片必须在php文件前面</em></p><p>注意：图片的内容要尽量简短，以防内容过于复杂存在的一些字符会影响到原来的php内容(可以用画图工具直接新建一个画图然后保存)</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
